#UVa221.城市正视图

**思路1**

这题的主要方法就是扫描法，但是具体怎么扫描有两种不同的思路

我最开始的思路是对南墙的左右**端点**排序后扫描，遇到一个左端点就把建筑插入扫描线set中并检查它的可见性，遇到一个右端点就从扫描线set里删掉它再检查扫描线中其他建筑的可见性。

对建筑定义一个x主序结构体，对左右端点定义一个x主序结构体，扫描线里建筑应该按y坐标排列，可以用map也可以再定义一个y主序结构体

**实现时遇到的问题**

1.  在udebug的测试样例上出现了段错误，定位到set的erase语句，发现在某个建筑的宽度为0，右端点比左端点先遇到扫描线，造成删除时发生非法内存访问。结局办法是在重载的小于运算符中要求左端点必须在右端点前
2.  提交OJ以后不幸WA，对拍发现在一些样例上给出了错误结果。这是因为我对左右端点做的是逐点扫描，如果建筑A的右端点和B的左端点x坐标相同，并且A和B都遮住了C，程序先扫描A的右端点就有可能错误地认为C在A被删除后可见。解决方法是把逐点扫描改成区间扫描，一次性插入删除同一x坐标的所有端点，然后再判断扫描线建筑的可见性

**思路2**

另一种思路是对端点排序后去重，然后扫描端点切分出的x坐标区间的**中点**，这样做不需要定义端点结构体，而且避免了对端点重合情况的处理，代价是每次都需要扫描所有建筑，找到扫描线上的建筑，按y坐标排序后再判断可见性

**语言细节**

如果要把小于运算符重载成类的成员函数，则必须把参数和函数本身都声明为`const`才能用于set和map的排序

#UVa1593.代码对齐

**思路**

把每列的最大长度保存在一个`vector`里。一次读入一行后扔进`stringstream`里，读出字符串并更新当前列最大长度后把字符串扔进`vecotr`里，最后把每行的`vector`也扔进`vector`里

输出时候按照每列的最大长度输出就行了，注意最后一列要特殊处理，不能有后继空格

**语言细节**

使用流操作符需要包含`iomanip`头文件

#UVa1594.Ducci序列

**思路1**

定义一个结构体保存元组，把每轮计算得到元组结构体放在`set`里来判断它是否出现过。注意每一轮用到的数都是上一轮的数，而不是本轮刚刚算出来的数

**遇到的问题**

实现的时候发现没法正确地用set判断是否重复，经检查发现是因为结构体的小于运算符重载方式有问题，不是严格弱序，尝试了这些解决方法：

1.  把小于定义成每个元素都较小：失败，仍然不是严格弱序
2.  用`stringstream`转化成字符串比较：效率太低
3.  索引法：直接用vector表示元组，把元组装进`set<vector<int> >`里：AC，但是效率仍然不高
4.  散列表：改用`unordered_set`（也就是散列表）判断是否循环，需要自定义散列函数，可以用Horner方法，也可以先左移，再异或，再右移

**编程细节**

一个比较函数`f(x,y)`满足弱序性当且仅当它满足以下四个性质

1.  反自反性：`f(x,x) == false`
2.  反对称性：`f(x,y) <-> !f(y,x)`
3.  传递性：`f(x,y) && f(y,z) -> f(x,z)`
4.  弱序性：`!f(x,y) && !f(y,x) <-> x == y`

使用`unordered_set`时要为vector定义散列函数，这个散列函数是仿函数的形式，并在定义`unordered_set`时作为模板参数一并传递

**思路2**

猜想：发生循环当且仅当某个元组含有0且非0元素都相同

**遇到的问题**

1.  发现不管怎么传参数都没办法在函数中使用数组，经检查，发现是因为主函数里声明的局部变量覆盖了表示数组大小的全局变量，导致全局变量读不进数据，无法进入循环
2.  经过试验，发现并不是所有满足条件的都是循环，猜想错误，但它很可能是必要不充分条件

# UVa10935.卡牌游戏

**思路**

这就是个步长为2的约瑟夫问题，用一个队列模拟这个过程即可

这提示我们：约瑟夫问题除了用环形链表和环形数组以外还可以用队列模拟，借助STL这十分简单

**遇到的问题**

第一次提交前没有用udebug检查，结果WA，检查发现是输出格式不对

# UVa10763.交换生

**思路**

本题是否存在可行方案与申请者的编号无关，我们只需要记录从一个地方到另一个地方有多少申请者即可。类似图的邻接表，用一张“剩余表”记录从a到b尚未配对的学生数。每读入一个申请者就判断他能否与尚未配对的人配对，能的话就配对，不能就把他也加入剩余表

剩余表可以用map的map实现（二维关联数组），外层map记录从a出发的剩余表，内层map记录从a到b的待配对学生数

**编程细节**

剩余表有两种更新策略，一种是`map[a][b]`为零时就移除`map[a][b]`结点，一种是为零时什么也不做。理论上前者的查找和更新效率更高但删除会带来额外的开销，而实验表明前者性能略好一些（9%左右的提升）

# UVa10391.复合词

**思路**

用一棵字典树表示词典中的所有词。对词典中的每一个词，通过字典树查找它在词典中的所有前缀并切割出后缀，如果任何一个后缀存在于词典中，则该词是复合词，否则不是

字典树本身用一个二维数组表示，字典树的值表可以用数组也可以用map实现

**遇到的问题**

1.  一开始无法插入字典树：检查后发现是因为创建新结点后忘记将当前结点设为新结点了
2.  udebug上的测试样例重复输出复合词：一旦发现有后缀存在于词典中就应立即退出循环
3.  一开始用map实现的字典树和暴力解法性能差不多，改用数组后性能提高了一倍

# UVa1595.对称轴

**思路**

左右对称轴存在当且仅当y坐标相同的点都关于同一个x坐标对称

按照上面的命题，先按y主x副序对所有点排序，然后进行区间扫描：y坐标相同，x坐标由小到大排列的点组成的区间应该关于某个中点对称，且这个中点应该是其他所有点的对称中点。记录并比较这个中点就能判断是否对称

实现的时候，用三个数组表示点的x坐标，y坐标和id（排序的时候需要移动点，因此需要记录每个位置的点的id）

注意：假设区间是`[i,j)`，那么区间内的比较指针`k=i to (i+j+1)/2`

**遇到的问题**

理论上整数运算比浮点数运算快，实际上OJ里浮点数反而用时更短，迷惑

**编程细节**

1.  因为中点有可能有小数部分，如果直接记录中点需要用浮点数，比较和计算也要用浮点数。为了提高性能，不是记录中点，而是记录中点的两倍，即避免了昂贵的浮点数计算又不需要担心精度问题
2.  本题中需要按y主序对点排序，因此需要自定义严格弱序的比较函数

# UVa12100.打印队列

**思路**

用队列模拟打印队列，用数组记录任务的优先级，用优先队列查找最高优先级，直接模拟打印过程即可

实现的时候在队列里保存id，用id作为优先级数组的索引，每完成一个打印任务需要删掉优先队列的顶部元素

**编程细节**

STL的优先队列在`<queue>`头文件中，`priority_queue`接受三个模板参数，第一个是优先级的数据类型，第二个是底层容器（默认为`vector`），第三个是比较函数（默认是`less<>`，起到最大优先队列的效果）

# UVa230.图书管理系统

**思路**

定义结构体`book`保存图书信息并重载小于运算符，用两个`set<book>`分别保存架上的书和待归架的书，用`mao`保存书名到作者的的映射，在输入指令时根据书名构造完整的`book`用于查找`set`

有了数据结构以后模拟就行了

**编程细节**

1.  合并不同指令中重合的操作，减小代码量
2.  不能在`foreach`遍历`set`时删除元素，否则会造成非法内存访问，发生段错误
3.  在插入元素前对元素调用`lower_bound`和`upper_bound`得到的结果相当奇怪，迷惑++
4.  `set`的迭代器不能`it-1`，因为`set`是关联容器，不是线性容器，不能随机访问

# UVa1596.找Bug

**思路**

用一张符号表记录可用符号，同时还需要记录所有已赋值数组元素，以及数组的大小

符号表可以用`map<string,map<int,int>>`来实现，把数组名映射到数组容器中，这里的数组容器用的是`map<int,int>`，这是因为数组容量可能非常大， 如果用线性容器可能占用过多空间甚至无法运行。数组大小用另一个`map`记录

有了数据结构后，解析并模拟程序运行即可，就好像解释器一样。这里要注意的是，表达式估值可以用递归来实现。不管是声明还是赋值都要先解析左值，获取数组名并对索引估值，这个操作可以合并

# UVa1597.Web搜索

**思路**

用一个vector的vector记录每篇文章的每一行（这是因为后面需要以文章为单位来查询和输出）

用一个`map<int,map<int,set<int>>>`表示反向索引，内层的`map<int,set<int>>`是桶，把出现了关键词的文章号与保存该文章中关键词行号的容器`set<int>`关联起来，形成从关键词到行号的三层索引。这里采用`set`是为了去重

输入文章时每读入一行就对该行建立反向索引

查询的时候根据查询命令类型的不同进行不同操作：

共同操作：查找出现A的所有行号，保存在`map<int,set<int>> ans`中

AND：找到出现B的所有行号（排除掉没出现关键词A的文章），然后从`ans`中剔除非共有文章，并在共有文章中插入出现B的行号

OR：找到出现B的所有行号，然后插入`ans`

输出的时候也要分情况：

非NOT：输出`ans`

NOT：输出不在`ans`中的文章的所有行

**遇到的问题**

1.  读入错误：`getline`之前忘记用`getchar`吃掉换行符
2.  `substr`越界：忘记判断指针是否越界
3.  查询时报段错误：忘记初始化指针
4.  OR查询得到错误的结果：设置状态变量时把OR和NOT设为了同一个值

**编程细节**

1.  在遍历`set/map`过程中，不要进行删除操作，否则会`RE`。必要时遍历副本，在原本中执行删除操作
2.  合并不同指令共有的操作，简化代码

#UVa12504.更新字典

**思路**

读入旧新字典，建立map，然后遍历map检查是否有新增、删除和修改即可

**遇到的问题**

一开始用`substr`不断截取输入字符串来读入字典，结果TLE，这是因为每次`substr`都会复制字符串（而不是像Java那样只是创建新的字符串对象），浪费了大量时间。最后改用`char[]`读取字典才AC

这再次显示了`string`的不足以及索引法的重要性：比起用大对象做键值，可以用对象的索引做键值并重载比较函数

**编程细节**

值可能非常大，所以也用字符串保存

# UVa511.地图查询

**思路**

反向索引

首先保存地图信息，把两个顶点处理成左下角和右上角坐标，方便后续处理

在输入位置信息的同时遍历地图，建立位置（字符串）到地图的索引，具体来说是建立一个`map<string,vector<int>>`，其中`vector<int>`是各个精细度等级下的匹配地图，`int`是地图的索引。这样一来查询时只需查找反向索引即可。注意：因为我们事先不清楚每个面积对应的精细度等级，在建立反向索引时需要用到临时的`map<double,int>`

**遇到的问题**

1.  输出的时候地图名总是最后一张地图名：一开始我认为是结构体构造函数传引用导致的，但排查后发现不是这样，因为`string`的赋值运算会构造一个新的字符串，源字符串改变不会影响结构体的字符串。后来发现是因为精细度等级反了，令`map`的比较函数为`std::greater`搞定

**编程细节**

1.  地图的信息保存在结构体里
2.  地图保存在`vector`中，其他函数用索引来访问地图，其他容器里只保存索引而不是结构体本身

# UVa822.客户中心模拟

**思路1**

离散化，扫描法

用结构体表示事件，对事件按照到达时间排序（到达时间相同的事件的顺序无关紧要）并放在`vector`中，同时建立一个事件编号到持续时间的`map`方便查询。用一个`set`表示待处理事件队列（之所以用`set`而不是队列是因为出队的事件不一定是队首事件）

用一个`vector`记录客服索引到`pid`的映射（`pid`只用于排序），为每个客服建立`tid`到优先级（整数越大优先级越高）的`map`，并把这些`map`塞进一个`vector`里，`vector`的索引就是客服索引。此外还需要一个`vector`表示客服当前的状态

算法流程为：

1.  扫描事件列表，假设当前扫描的事件到达时间是`t`，扫过后面所有到达时间也是`t`的事件并把它们加入待处理队列
2.  为客服建立一个优先队列，按照客服服务结束时间排序，同一结束时间的按上次开始处理请求的时间排序，最后按`pid`排序
3.  把所有结束服务时间大于前次时间，小于当前时间的客服加入优先队列
4.  取队首客服，遍历队列为他分配事件。如果有他能处理的事件，且处理该事件的结束时间小于当前时间，就把他重新加入优先队列，否则需要等待
5.  重复步骤4直到优先队列为空
6.  扫描所有客服，把结束时间小于等于当前时间的客服的结束时间设为当前时间（他们都要等到当前时间才能处理请求，等效于结束时间都是当前时间，然后按规则竞争），然后加入优先队列
7.  反复取队首客服并分配事件，直到优先队列为空。因为事件处理用时大于零，所有这次无需再反复入队
8.  上述步骤结束后，客服分为两种：无所事事的和正在忙碌的
9.  重复步骤1-8，直到扫描完所有事件
10.  把当前时间设为正无穷，重复步骤2-7直到所有事件都被处理完，最后结束的事件的结束时间就是总时长

**编程细节**

1.  `set`的元素唯一，所以等待队列的比较函数一定要确保开始时间相同的事件能通过`tid`区分
2.  记得在每轮开始的时候清空全局变量

**思路2**

同样是离散化，这次从更一般的角度出发

系统的状态包含客服的状态和已经到达的事件，只有在有客服完成服务，或者有新事件到达时系统状态才发生改变

依然为事件与客服定义结构体，但这次不再引入待处理事件队列，而是在每类事件的结构体中追踪新事件的发生时间，以及待处理的第一个事件（每次选择都先选择第一个待处理事件）。客服结构体中保存客服的优先级列表

每一次系统状态改变时做两件事：维护系统状态，判断下次状态改变的时间

维护系统状态：遍历客服，为每位空闲客服按照他的优先级列表选择事件，然后更新等待事件

判断下次状态改变的时间：服务结束时间与新事件发生时间中最小的时间就是下次状态改变的时间

反复更新状态，直到所有主题都被处理完。最后被处理完的事件的结束时间（也就是最后一次状态变化时间）就是总时间

**遇到的问题**

1.  每次主题剩余事件数变成零就令剩余主题数减1，同时以剩余主题数非0为停止条件。但是主题无剩余不等于处理完成，导致时间偏小。解决方法是以下次跳转时间为无穷为停止条件（也即无待处理事件，并且所有人都完成了工作）
2.  当一个客服成功选中事件后没有立即跳过他，导致一个客服一次选择多个事件
3.  在排序时不需要考虑`tend`，因为当前正忙的客服不需要选事件，需要选事件的客服不需要考虑`tend`

**编程细节**

`map`的值是对象时需要有默认构造函数

# UVa1598.交易系统

**思路**

索引优先队列

买单和买单各是一个索引优先队列，先按价位排序再按索引排序，取消指令需要用到索引。C++里没有索引优先队列，但是可以通过自定义比较函数用`set`实现索引优先队列

**编程细节**

1.  买单和买单的比较方式不同
2.  本题输入量较大，注意不要超时

# UVa12333.斐波那契的复仇

**思路**

序号为10万的斐波那契数长达数十万位，既不可能用原始数据类型保存也不可能高精度保存。受到浮点数和动态数组技术的启发，我们只保存前120位，并在长度超过120时截取高60位，移动到低60位，也就是确保60位精度

为了方便查找，可以把斐波那契数的高40位保存在10向字典树中。具体来说，字典树的值是该前缀对应的最小序号。插入的时候，如果某个结点已经有值，说明已经有序号更小的匹配前缀的斐波那契数，什么也不干；如果结点还没被碰过，就更新序号

**编程细节**

1.  本题需要保存的字符非常多，因此字典树结点也非常多
2.  计算斐波那契数采用DP+滚动数组
3.  大整数相加采用逐位加法，而不是分段加法，这是为了方便输出，减小代码量，并且效率相差无几

#UVa212.医院设备利用

**思路**

离散化系统模拟

这个系统的状态可以简化成手术室的状态，只需要考察手术室状态变化的时间，其他状态都可以从手术室状态推导出来。需要注意的是，判断哪些手术室（或恢复室）空闲之前需要先完成状态转移

**遇到的问题**

1.  总是选择错误的床号。检查发现是因为更新床的状态后忘记再次判断床是否应该继续状态转换
2.  还是选错行号：题目要求选择“结束手术时空闲的床”，而我选择的是“病人到达床位时空闲的床”，想来也有道理，一出手术室就应该决定去哪张床，不然往哪转移呢（恢复床不一定在同一区域），这样也可以避免对床位的密集使用

**编程细节**

1.  格式化输出浮点数时指定的场宽包括小数点